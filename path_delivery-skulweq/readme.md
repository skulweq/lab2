Это шаблонны проект для выполнения ДЗ

## Запуск Сборки и тестов через терминал

```bash
cmake -B build # Генерируем файлы сборки
cmake --build build # Собираем
cd build # Заходим в дерикторию сборки
ctest --output-on-failure # Запуск тестов
```

### **Задача: Поиск кратчайшего пути между городами (Алгоритм Дейкстры)**

---

#### **Цель задания**  
Реализовать алгоритм Дейкстры для поиска кратчайшего пути в графе городов, соединённых дорогами с определённой стоимостью проезда.  
**Используемые структуры данных:**  
- `std::priority_queue` для эффективного выбора следующей вершины.
- Контейнеры STL для представления графа (например, `std::unordered_map`).

---

#### **Описание задачи**  
Представьте, что у вас есть карта городов, где:
- Каждый город — это вершина графа.
- Дороги между городами — это рёбра графа с **положительной** стоимостью (весом) проезда.

**Требуется:**  
Написать программу, которая для двух заданных городов находит путь с **минимальной суммарной стоимостью** и возвращает последовательность городов на этом пути.

---

#### **Входные данные**  
Граф задаётся программно через добавление рёбер. Пример использования класса:
```cpp
Graph graph;
graph.add_edge("Москва", "Санкт-Петербург", 705);  // Длина дороги в км
graph.add_edge("Санкт-Петербург", "Псков", 290);
...
auto path = graph.find_shortest_path("Москва", "Псков");
```

---

#### **Требования к реализации**  
1. **Класс `Graph`:**
   - Метод `add_edge(from, to, cost)` добавляет дорогу между городами `from` и `to` с указанной стоимостью.
   - Метод `find_shortest_path(start, end)` возвращает вектор городов в порядке следования от `start` до `end`.
   - Если пути не существует, метод возвращает пустой вектор.

2. **Алгоритм Дейкстры:**
   - Использовать `std::priority_queue` для оптимизации выбора следующей вершины.
   - Учитывать, что стоимость дорог всегда положительна.

3. **Обработка ошибок:**
   - Если города `start` или `end` отсутствуют в графе, выбросить исключение (например, `std::invalid_argument`).

---

#### **Примеры**

**Пример 1**  
```cpp
Graph g;
g.add_edge("A", "B", 4);
g.add_edge("A", "C", 2);
g.add_edge("B", "C", 5);
g.add_edge("C", "D", 3);

auto path = g.find_shortest_path("A", "D");
// Результат: {"A", "C", "D"}, суммарная стоимость = 2 + 3 = 5
```

**Пример 2**  
```cpp
Graph g;
g.add_edge("A", "B", 10);
g.add_edge("B", "C", 15);
g.add_edge("A", "C", 100);

auto path = g.find_shortest_path("A", "C");
// Результат: {"A", "B", "C"}, стоимость = 10 + 15 = 25
```

**Пример 3 (Нет пути)**  
```cpp
Graph g;
g.add_edge("X", "Y", 5);
auto path = g.find_shortest_path("X", "Z");  // Пустой вектор
```

---

#### **Примечания**  
1. **Граф ориентированный?**  
   Нет, дороги считаются двусторонними (неориентированный граф). Если добавлено ребро `A -> B`, подразумевается, что движение возможно и в обратную сторону (`B -> A`).

2. **Советы по реализации:**  
   - Для хранения расстояний используйте словарь (`std::unordered_map<std::string, int>`).
   - Для отслеживания предыдущих вершин на пути используйте ещё один словарь.
   - Приоритетная очередь должна хранить пары `(текущая_стоимость, город)`.

---

#### **Как тестировать своё решение**  
1. **Простые случаи:**  
   - Путь из города в самого себя.
   - Граф из двух городов с одной дорогой.

2. **Сложные случаи:**  
   - Циклические маршруты.
   - Несколько возможных путей с разной стоимостью.

3. **Краевые случаи:**  
   - Город без дорог.
   - Запрос пути между несвязанными городами.

---

#### **Шаблон кода**  
```cpp
#include <string>
#include <vector>
#include <queue>
#include <unordered_map>

class Graph {
public:
    void add_edge(const std::string& from, const std::string& to, int cost) {
        // Реализуйте добавление рёбер
    }

    std::vector<std::string> find_shortest_path(const std::string& start, 
                                             const std::string& end) {
        // Реализуйте алгоритм Дейкстры
    }
};
```
